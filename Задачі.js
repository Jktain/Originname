// 1)Что выведет функция?

// function f() {
//   alert( this ); // ?
// }

// let user = {
//   g: f.bind(null)
// };

// user.g();

// Ответ: null.
// Контекст связанной функции жёстко фиксирован. Изменить однажды 
//     привязанный контекст уже нельзя.

// Так что хоть мы и вызываем user.g(), внутри исходная функция будет 
//     вызвана с this=null. Однако, функции g совершенно без разницы, 
//     какой this она получила. Её единственное предназначение – это 
//     передать вызов в f вместе с аргументами и ранее указанным 
//     контекстом null, что она и делает.

// Таким образом, когда мы запускаем user.g(), исходная функция 
//     вызывается с this=null.

//------------------------------------------- 2 -------------------------------------------
// Можем ли мы изменить this дополнительным связыванием?

// Что выведет этот код?

// function f() {
//   alert(this.name);
// }

// f = f.bind( {name: "Вася"} ).bind( {name: "Петя" } );

// f();

// Ответ: Вася
// Экзотический объект bound function, возвращаемый при первом вызове
//     f.bind(...), запоминает контекст (и аргументы, если они были
//     переданы) только во время создания.

// Следующий вызов bind будет устанавливать контекст уже для этого 
//     объекта. Это ни на что не повлияет.

// Можно сделать новую привязку, но нельзя изменить существующую.

//------------------------------------------- 3 -------------------------------------------
// В свойство функции записано значение. Изменится ли оно после 
//     применения bind? Обоснуйте ответ.
// function sayHi() {
//   alert( this.name );
// }
// sayHi.test = 5;

// let bound = sayHi.bind({
//   name: "Вася"
// });

// alert( bound.test ); // что выведет? почему?

// Ответ: undefined.

// Результатом работы bind является другой объект. 
//     У него уже нет свойства test.


//------------------------------------------- 4 -------------------------------------------
// Вызов askPassword() в приведённом ниже коде должен проверить пароль
//     и затем вызвать user.loginOk/loginFail в зависимости от ответа.

// Однако, его вызов приводит к ошибке. Почему?

// function askPassword(ok, fail) {
//     let password = prompt("Password?", '');
//     if (password == "rockstar") ok();
//     else fail();
//   }
  
//   let user = {
//     name: 'Вася',
  
//     loginOk() {
//       alert(`${this.name} logged in`);
//     },
  
//     loginFail() {
//       alert(`${this.name} failed to log in`);
//     },
  
//   };
  
//   askPassword(user.loginOk, user.loginFail);

// Ответ: Ошибка происходит потому, что askPassword получает функции
//     loginOk/loginFail без контекста.

// Когда они вызываются, то, естественно, this=undefined.

// Используем bind, чтобы передать в askPassword функции 
//     loginOk/loginFail с уже привязанным контекстом:

// askPassword(user.loginOk.bind(user), user.loginFail.bind(user));

//------------------------------------------- 5 -------------------------------------------
// Объект user был изменён. Теперь вместо двух функций loginOk/loginFail
//     у него есть только одна – user.login(true/false).

// Что нужно передать в вызов функции askPassword в коде ниже, чтобы 
//     она могла вызывать функцию user.login(true) как ok и функцию 
//     user.login(false) как fail?

// function askPassword(ok, fail) {
//   let password = prompt("Password?", '');
//   if (password == "rockstar") ok();
//   else fail();
// }

// let user = {
//   name: 'John',

//   login(result) {
//     alert( this.name + (result ? ' logged in' : ' failed to log in') );
//   }
// };

// askPassword(?, ?); // ?

// Ответ: 
// 1)
//     Можно использовать стрелочную функцию-обёртку:

//     askPassword(() => user.login(true), () => user.login(false));
//     Теперь она получает user извне и нормально выполняется.

// 2) 
//     Или же можно создать частично применённую функцию на основе 
//         user.login, которая использует объект user в качестве контекста
//         и получает соответствующий первый аргумент:

//     askPassword(user.login.bind(user, true), user.login.bind(user, false));

//------------------------------------------- 6 -------------------------------------------


// Ответ:


//------------------------------------------- 7 -------------------------------------------


// Ответ: 


//------------------------------------------- 8 -------------------------------------------


// Ответ:


//------------------------------------------- 9 -------------------------------------------


// Ответ: 


//------------------------------------------- 10 -------------------------------------------


// Ответ:


//------------------------------------------- 11 -------------------------------------------


// Ответ: 


//------------------------------------------- 12 -------------------------------------------


// Ответ:


//------------------------------------------- 13 -------------------------------------------


// Ответ:

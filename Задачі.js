// 1) Этот цикл – бесконечный. Он никогда не завершится, почему?

// let i = 0;
// while (i != 10) {
//   i += 0.2;
// }

// Ответ: Потому что i никогда не станет равным 10.

// Запустите скрипт и вы увидите реальные значения i:

// let i = 0;
// while (i < 11) {
//   i += 0.2;
//   if (i > 9.8 && i < 10.2) alert( i );
// }
// Ни одно из этих чисел не равно 10.

// Это происходит из-за потери точности, при прибавлении таких дробей как 0.2.

// Вывод: избегайте проверок на равенство при работе с десятичными дробями.

//------------------------------------------- 2 -------------------------------------------
// Создайте скрипт, который запрашивает ввод двух чисел (используйте prompt) 
//     и после показывает их сумму.

// Ответ: 
// let a = +prompt("Введите первое число", "");
// let b = +prompt("Введите второе число", "");

// alert( a + b );
// Обратите внимание, что мы использовали унарный оператор + перед prompt, он преобразует
//     значение в числовой формат.

// В противном случае, a и b будут строками, и после суммирования произойдёт конкатенация
//     двух строк, а именно: "1" + "2" = "12".

//------------------------------------------- 3 -------------------------------------------
// Методы Math.round и toFixed, согласно документации, округляют до ближайшего целого
//     числа: 0..4 округляется в меньшую сторону, тогда как 5..9 в большую сторону.

// Например:

// alert( 1.35.toFixed(1) ); // 1.4
// Но почему в примере ниже 6.35 округляется до 6.3?

// alert( 6.35.toFixed(1) ); // 6.3
// Как правильно округлить 6.35?

// Ответ:
// Во внутреннем двоичном представлении 6.35 является бесконечной двоичной дробью. 
//     Хранится она с потерей точности…

// Давайте посмотрим:

// alert( 6.35.toFixed(20) ); // 6.34999999999999964473
// Потеря точности может как увеличивать, так и уменьшать число. В данном случае число 
//     становится чуть меньше, поэтому оно округляется в меньшую сторону.

// А для числа 1.35?

// alert( 1.35.toFixed(20) ); // 1.35000000000000008882
// Тут потеря точности приводит к увеличению числа, поэтому округление произойдёт 
//     в большую сторону.

// Каким образом можно исправить ошибку в округлении числа 6.35?

// Мы должны приблизить его к целому числу, перед округлением:

// alert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000
// Обратите внимание, что для числа 63.5 не происходит потери точности. Дело в том, 
//     что десятичная часть 0.5 на самом деле 1/2. Дробные числа, делённые на степень 2,
//     точно представлены в двоичной системе, теперь мы можем округлить число:

// alert( Math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(rounded) -> 6.4

//------------------------------------------- 4 -------------------------------------------
// Встроенный метод Math.random() возвращает случайное число от 0 (включительно) до 1
//     (но не включая 1)

// Напишите функцию random(min, max), которая генерирует случайное число с плавающей 
//     точкой от min до max (но не включая max).

// Ответ:
// Нам нужно преобразовать каждое значение из интервала 0…1 в значения от min до max.

// Это можно сделать в 2 шага:

// Если мы умножим случайное число от 0…1 на max-min, тогда интервал возможных значений
//     от 0..1 увеличивается до 0..max-min.
// И, если мы прибавим min, то интервал станет от min до max.
// Функция:

// function random(min, max) {
//   return min + Math.random() * (max - min);
// }

// alert( random(1, 5) );
// alert( random(1, 5) );
// alert( random(1, 5) );

//------------------------------------------- 5 -------------------------------------------
// Создайте функцию readNumber, которая будет запрашивать ввод числового значения
//     до тех пор, пока посетитель его не введёт.

// Функция должна возвращать числовое значение.

// Также надо разрешить пользователю остановить процесс ввода, отправив пустую строку 
//     или нажав «Отмена». В этом случае функция должна вернуть null.

// Ответ: 
// function readNumber() {
//     let num;
  
//     do {
//       num = prompt("Введите число", 0);
//     } while ( !isFinite(num) );
  
//     if (num === null || num === '') return null;
  
//     return +num;
//   }
  
//   alert(`Число: ${readNumber()}`);
//   Решение немного сложнее, чем могло бы быть, потому что нам надо обрабатывать null
//     и пустую строку.
  
//   Следовательно, запрашиваем ввод числового значения, пока посетитель его не введёт.
//     И null (отмена) и пустая строка также соответствуют данному условию, 
//     потому что при приведении к числу они равны 0.
  
//   После того, как цикл завершится, нам нужно проверить введённое значение на null
//     и пустую строку (вернуть null), потому что после преобразования null в число,
//     функция вернёт 0.

//------------------------------------------- 6 -------------------------------------------
// Напишите функцию randomInteger(min, max), которая генерирует случайное целое (integer)
//     число от min до max (включительно).

// Любое число из интервала min..max должно появляться с одинаковой вероятностью.

// Ответ:
// 1) Простое, но неправильное решение
//     Самое простое, но неправильное решение – генерировать случайное число от min до max
//         и округлять его:

//     function randomInteger(min, max) {
//     let rand = min + Math.random() * (max - min);
//     return Math.round(rand);
//     }

//     alert( randomInteger(1, 3) );
//     Функция будет работать, но неправильно. Вероятность получить min и max значения
//         в 2 раза меньше, чем любое другое число.

//     Если вы запустите приведённый выше пример, то заметите, что 2 появляется чаще всего.

//     Это происходит потому, что метод Math.round() получает случайные числа
//         из интервала 1..3 и округляет их следующим образом:

//     число от 1    ... до 1.4999999999  округлится до 1
//     число от 1.5  ... до 2.4999999999  округлится до 2
//     число от 2.5  ... до 2.9999999999  округлится до 3
//     Теперь становится понятно, что 1 получает в 2 раза меньше значений, чем 2.
//         То же самое с 3.

// 2) Правильное решение задачи
//     Есть много правильных решений этой задачи. Одно из них – правильно указать
//         границы интервала. Чтобы выровнять интервалы, мы можем генерировать числа
//         от 0.5 до 3.5, это позволит добавить необходимые вероятности к min и max:

//     function randomInteger(min, max) {
//     // получить случайное число от (min-0.5) до (max+0.5)
//     let rand = min - 0.5 + Math.random() * (max - min + 1);
//     return Math.round(rand);
//     }

//     alert( randomInteger(1, 3) );
//     Другое правильное решение – это использовать Math.floor для получения случайного
//         числа от min до max+1:

//     function randomInteger(min, max) {
//     // случайное число от min до (max+1)
//     let rand = min + Math.random() * (max + 1 - min);
//     return Math.floor(rand);
//     }

//     alert( randomInteger(1, 3) );
//     Теперь все интервалы отображаются следующим образом:

//     число от 1  ... до 1.9999999999  округлится до 1
//     число от 2  ... до 2.9999999999  округлится до 2
//     число от 3  ... до 3.9999999999  округлится до 3
//     Все интервалы имеют одинаковую длину, что выравнивает вероятность получения
//         случайных чисел.

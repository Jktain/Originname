// 1)Допустим, у нас есть массив arr.

// Создайте функцию unique(arr), которая вернёт массив уникальных, не 
//     повторяющихся значений массива arr.Допустим, у нас есть массив arr

// Ответ: 
// function unique(arr) {
//     return Array.from(new Set(arr));
//   }
  
//   let values = ["Hare", "Krishna", "Hare", "Krishna",
//     "Krishna", "Krishna", "Hare", "Hare", ":-O"
//   ];
  
//   console.log( unique(values) ); // Hare,Krishna,:-O

//------------------------------------------- 2 -------------------------------------------
// Анаграммы – это слова, у которых те же буквы в том же количестве, но
//     они располагаются в другом порядке.

// Например:

// nap - pan
// ear - are - era
// cheaters - hectares - teachers
// Напишите функцию aclean(arr), которая возвращает массив слов, 
//     очищенный от анаграмм.

// Ответ: 
// Чтобы найти все анаграммы, давайте разобьём каждое слово на буквы 
//     и отсортируем их, а потом объединим получившийся массив снова 
//     в строку. После этого все анаграммы будут одинаковы.

// Например:

// nap, pan -> anp
// ear, era, are -> aer
// cheaters, hectares, teachers -> aceehrst
// ...
// Мы будем использовать отсортированные строки как ключи в коллекции
//     Map, для того чтобы сопоставить каждому ключу только одно значение:

// function aclean(arr) {
//   let map = new Map();

//   for (let word of arr) {
//     // разбиваем слово на буквы, сортируем и объединяем снова в строку
//     let sorted = word.toLowerCase()
//                      .split("")
//                      .sort()
//                      .join("");
//     map.set(sorted, word);
//   }

//   return Array.from(map.values());
// }

// let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

// alert( aclean(arr) );

// Если мы когда-либо ещё встретим слово в той же отсортированной форме, 
//     тогда это слово перезапишет значение с тем же ключом в объекте. 
//     Таким образом, нескольким словам у нас будет всегда 
//     соответствовать одна отсортированная форма.

// В конце Array.from(map.values()) принимает итерируемый объект значений
//     объекта Map (в данном случае нам не нужны ключи) и возвращает их
//     в виде массива.

//------------------------------------------- 3 -------------------------------------------
// Мы хотели бы получить массив ключей map.keys() в переменную и далее 
//     работать с ними, например, применить метод .push.

// Но это не выходит:

// let map = new Map();

// map.set("name", "John");

// let keys = map.keys();

// // Error: keys.push is not a function
// // Ошибка: keys.push -- это не функция
// keys.push("more");
// Почему? Что нужно поправить в коде, чтобы вызов keys.push сработал?

// Ответ:
// Это потому что map.keys() возвращает итерируемый объект, а не массив.

// Мы можем конвертировать его в массив с помощью Array.from:

// let map = new Map();

// map.set("name", "John");

// let keys = Array.from(map.keys());

// keys.push("more");

// alert(keys); // name, more

//------------------------------------------- 4 -------------------------------------------


// Ответ:


//------------------------------------------- 5 -------------------------------------------


// Ответ: 


//------------------------------------------- 6 -------------------------------------------


// Ответ:


//------------------------------------------- 7 -------------------------------------------


// Ответ: 


//------------------------------------------- 8 -------------------------------------------


// Ответ:


//------------------------------------------- 9 -------------------------------------------


// Ответ: 


//------------------------------------------- 10 -------------------------------------------


// Ответ:


//------------------------------------------- 11 -------------------------------------------


// Ответ: 


//------------------------------------------- 12 -------------------------------------------


// Ответ:


//------------------------------------------- 13 -------------------------------------------


// Ответ:

// Пустой объект можно создать, используя один из двух вариантов 
//     синтаксиса:

// let user = new Object(); // синтаксис "конструктор объекта"
// let user = {};  // синтаксис "литерал объекта"
// Обычно используют вариант с фигурными скобками {...}. Такое 
//     объявление называют литералом объекта или литеральной нотацией.

//--------------------- Литералы и свойства ----------------------------
// При использовании литерального синтаксиса {...} мы сразу можем
//     поместить в объект несколько свойств в виде пар «ключ: значение»:

// let user = {     // объект
//   name: "John",  // под ключом "name" хранится значение "John"
//   age: 30        // под ключом "age" хранится значение 30
// };Для обращения к свойствам используется запись «через точку»:

// получаем свойства объекта:
// alert( user.name ); // John
// alert( user.age ); // 30
// Значение может быть любого типа. Давайте добавим свойство с 
//     логическим значением:

// user.isAdmin = true;
// Для удаления свойства мы можем использовать оператор delete:

// delete user.age;
// Имя свойства может состоять из нескольких слов, но тогда оно должно
//     быть заключено в кавычки:

// let user = {
//   name: "John",
//   age: 30,
//   "likes birds": true  
// };

// Последнее свойство объекта может заканчиваться запятой:

// let user = {
//   name: "John",
//   age: 30,
// }
// Это называется «висячая запятая». Такой подход упрощает добавление,
//     удаление и перемещение свойств, так как все строки объекта 
//     становятся одинаковыми.

// Объект, объявленный через const, может быть изменён. Например:

// const user = {
//   name: "John"
// };

// user.name = "Pete"; // (*)

// alert(user.name); // Pete

//------------------------ Квадратные скобки ---------------------------
// Для свойств, имена которых состоят из нескольких слов, доступ к
//     значению «через точку» не работает:

// это вызовет синтаксическую ошибку
// user.likes birds = true
// Для таких случаев существует альтернативный способ доступа к 
//     свойствам через квадратные скобки. Такой способ сработает с
//     любым именем свойства:

// let user = {};

// присваивание значения свойству
// user["likes birds"] = true;

// получение значения свойства
// alert(user["likes birds"]); // true

// удаление свойства
// delete user["likes birds"];
// Cтрока в квадратных скобках заключена в кавычки (подойдёт любой
//      тип кавычек).
// Квадратные скобки также позволяют обратиться к свойству, имя которого
//      может быть результатом выражения. Например, имя свойства может
//      храниться в переменной:

// let key = "likes birds";

// то же самое, что и user["likes birds"] = true;
// user[key] = true;
// Здесь переменная key может быть вычислена во время выполнения кода 
//     или зависеть от пользовательского ввода. После этого мы 
//     используем её для доступа к свойству. Это даёт нам большую 
//     гибкость.

// Пример:

// let user = {
//   name: "John",
//   age: 30
// };

// let key = prompt("Что вы хотите узнать о пользователе?", "name");

// доступ к свойству через переменную
// alert( user[key] ); // John (если ввели "name")

//---------------------- Вычисляемые свойства --------------------------
// Мы можем использовать квадратные скобки в литеральной нотации для
//     создания вычисляемого свойства.
// Пример:

// let fruit = prompt("Какой фрукт купить?", "apple");

// let bag = {
//   [fruit]: 5, // имя свойства будет взято из переменной fruit
// };

// alert( bag.apple ); // 5, если fruit="apple"
// Смысл вычисляемого свойства прост: запись [fruit] означает, что имя
//     свойства необходимо взять из переменной fruit.

// И если посетитель введёт слово "apple", то в объекте bag теперь будет
//     лежать свойство {apple: 5}.

// По сути, пример выше работает так же, как и следующий пример:

// let fruit = prompt("Какой фрукт купить?", "apple");
// let bag = {};

// bag[fruit] = 5;
// …Но первый пример выглядит лаконичнее.

// Мы можем использовать и более сложные выражения в квадратных скобках:

// let fruit = 'apple';
// let bag = {
//   [fruit + 'Computers']: 5 // bag.appleComputers = 5
// };
// Квадратные скобки дают намного больше возможностей, чем запись через
//     точку. Они позволяют использовать любые имена свойств и 
//     переменные, хотя и требуют более громоздких конструкций кода.

//--------------------- Свойство из переменной -------------------------
// В реальном коде часто нам необходимо использовать существующие 
//      переменные как значения для свойств с тем же именем.

// Например:

// function makeUser(name, age) {
//   return {
//     name: name,
//     age: age
//     // ...другие свойства
//   };
// }

// let user = makeUser("John", 30);
// alert(user.name); // John
// В примере выше название свойств name и age совпадают с названиями
//      переменных, которые мы подставляем в качестве значений этих 
//      свойств. Такой подход настолько распространён, что существуют 
//      специальные короткие свойства для упрощения этой записи.

// Вместо name:name мы можем написать просто name:

// function makeUser(name, age) {
//   return {
//     name, // то же самое, что и name: name
//     age   // то же самое, что и age: age
//     // ...
//   };
// }
// Мы можем использовать как обычные свойства, так и короткие в одном и 
//      том же объекте:

// let user = {
//   name,  // тоже самое, что и name:name
//   age: 30
// };

//------------------ Ограничения на имена свойств ----------------------
// Как мы уже знаем, имя переменной не может совпадать с 
    //зарезервированными словами, такими как «for», «let», «return» и тд

// Но для свойств объекта такого ограничения нет:

// let obj = {
//   for: 1,
//   let: 2,
//   return: 3
// };

// alert( obj.for + obj.let + obj.return );  // 6
// Иными словами, нет никаких ограничений к именам свойств. Они могут 
//     быть в виде строк или символов (специальный тип для 
//     идентификаторов, который будет рассмотрен позже).

// Все другие типы данных будут автоматически преобразованы к строке.

// Например, если использовать число 0 в качестве ключа, то оно 
//      превратится в строку "0":

// let obj = {
//   0: "Тест" // то же самое что и "0": "Тест"
// };

// alert( obj["0"] ); // Тест
// alert( obj[0] ); // Тест (то же свойство)
// Есть небольшой подводный камень, связанный со специальным свойством 
//      __proto__. Мы не можем установить его в необъектное значение:

// let obj = {};
// obj.__proto__ = 5; // присвоим число
// alert(obj.__proto__); // [object Object], значение - это объект, 
//      т.е. не то, что мы ожидали

//----------- Проверка существования свойства, оператор «in» -----------
// В отличие от многих других языков, особенность JavaScript-объектов в
//     том, что можно получить доступ к любому свойству. Даже если
//     свойства не существует – ошибки не будет!

// При обращении к свойству, которого нет, возвращается undefined. Это 
//      позволяет просто проверить существование свойства:

// let user = {};

// alert( user.noSuchProperty === undefined ); // true означает 
//      "свойства нет"
// Также существует специальный оператор "in" для проверки существования
//      свойства в объекте.

// Синтаксис оператора:

// "key" in object
// Пример:

// let user = { name: "John", age: 30 };

// alert( "age" in user ); // true, user.age существует
// alert( "blabla" in user ); // false, user.blabla не существует
// Обратите внимание, что слева от оператора in должно быть имя 
//      свойства. Обычно это строка в кавычках.

// Если мы опускаем кавычки, это значит, что мы указываем переменную, в
//      которой находится имя свойства. Например:

// let user = { age: 30 };

// let key = "age";
// alert( key in user ); // true, имя свойства было взято из переменной
//      key
// Для чего вообще нужен оператор in? Разве недостаточно сравнения с
//      undefined?

// В большинстве случаев прекрасно сработает сравнение с undefined. Но
//      есть особый случай, когда оно не подходит, и нужно использовать
//      "in". Это когда свойство существует, но содержит значение
//      undefined:

// let obj = {
//   test: undefined
// };

// alert( obj.test ); //  выведет undefined
// alert( "test" in obj ); // true, свойство существует!
// В примере выше свойство obj.test технически существует в объекте. 
//      Оператор in сработал правильно.

// Подобные ситуации случаются очень редко, так как undefined обычно
//      явно не присваивается. Для «неизвестных» или «пустых» свойств мы
//      используем значение null. Таким образом, оператор in является
//      экзотическим гостем в коде.

//-------------------------- Цикл «for…in» -----------------------------
// Для перебора всех свойств объекта используется цикл for..in. Этот 
//      цикл отличается от изученного ранее цикла for(;;).

// Синтаксис:

// for (key in object) {
//   // тело цикла выполняется для каждого свойства объекта
// }
// К примеру, давайте выведем все свойства объекта user:

// let user = {
//   name: "John",
//   age: 30,
//   isAdmin: true
// };

// for (let key in user) {
//   // ключи
//   alert( key );  // name, age, isAdmin
//   // значения ключей
//   alert( user[key] ); // John, 30, true
// }
// Обратите внимание, что все конструкции «for» позволяют нам объявлять
//      переменную внутри цикла, как, например, let key здесь.

// Кроме того, мы могли бы использовать другое имя переменной. Например,
//  часто используется вариант "for (let prop in obj)".

//------------------- Упорядочение свойств объекта ---------------------
// Упорядочены ли свойства объекта? Другими словами, если мы будем в 
//     цикле перебирать все свойства объекта, получим ли мы их в том же
//     порядке, в котором мы их добавляли? Можем ли мы на это 
//     рассчитывать?

// Короткий ответ: свойства упорядочены особым образом: свойства с 
//     целочисленными ключами сортируются по возрастанию, остальные 
//     располагаются в порядке создания. Разберёмся подробнее.

// В качестве примера рассмотрим объект с телефонными кодами:

// let codes = {
//   "49": "Германия",
//   "41": "Швейцария",
//   "44": "Великобритания",
//   // ..,
//   "1": "США"
// };

// for (let code in codes) {
//   alert(code); // 1, 41, 44, 49
// }
// Если мы делаем сайт для немецкой аудитории, то, вероятно, мы хотим,
//      чтобы код 49 был первым.

// Но если мы запустим код, мы увидим совершенно другую картину:

// США (1) идёт первым
// затем Швейцария (41) и так далее.
// Телефонные коды идут в порядке возрастания, потому что они являются
//      целыми числами: 1, 41, 44, 49.
// Термин «целочисленное свойство» означает строку, которая может быть
//      преобразована в целое число и обратно без изменений.

// То есть, "49" – это целочисленное имя свойства, потому что если его
//      преобразовать в целое число, а затем обратно в строку, то оно
//      не изменится. А вот свойства "+49" или "1.2" таковыми не
//      являются:
// …С другой стороны, если ключи не целочисленные, то они перебираются
//      в порядке создания, например:

// let user = {
//   name: "John",
//   surname: "Smith"
// };
// user.age = 25; // добавим ещё одно свойство

// // не целочисленные свойства перечислены в порядке создания
// for (let prop in user) {
//   alert( prop ); // name, surname, age
// }
// Таким образом, чтобы решить нашу проблему с телефонными кодами, мы
//     можем схитрить, сделав коды не целочисленными свойствами. 
//     Добавления знака "+" перед каждым кодом будет достаточно.

// Пример:

// let codes = {
//   "+49": "Германия",
//   "+41": "Швейцария",
//   "+44": "Великобритания",
//   // ..,
//   "+1": "США"
// };

// for (let code in codes) {
//   alert( +code ); // 49, 41, 44, 1
// }
// Теперь код работает так, как мы задумывали.
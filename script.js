// Мы можем скопировать функцию в другую переменную:

// function sayHi() {   // (1) создаём
//   alert( "Привет" );
// }

// let func = sayHi;    // (2) копируем

// func(); // Привет    // (3) вызываем копию (работает)!
// sayHi(); // Привет   //     прежняя тоже работает (почему бы нет)
// Давайте подробно разберём всё, что тут произошло:

// Объявление Function Declaration (1) создало функцию и присвоило её
// значение переменной с именем sayHi. В строке (2) мы скопировали её
// значение в переменную func. Обратите внимание (ещё раз): нет круглых
// скобок после sayHi. Если бы они были, то выражение func = sayHi() 
// записало бы результат вызова sayHi() в переменную func, а не саму 
// функцию sayHi.Теперь функция может быть вызвана с помощью обеих 
// переменных sayHi() и func().Заметим, что мы могли бы использовать и
// Function Expression для того, чтобы создать sayHi в первой строке:

// let sayHi = function() {
//   alert( "Привет" );
// };

// let func = sayHi;
// ...
//---------------------------- Функции-«колбэки» -----------------------
// Давайте напишем функцию ask(question, yes, no) с тремя параметрами:
// question - Текст вопроса
// yes - Функция, которая будет вызываться, если ответ будет «Yes»
// no - Функция, которая будет вызываться, если ответ будет «No»
// Наша функция должна задать вопрос question и, в зависимости от того,
// как ответит пользователь, вызвать yes() или no():

// function ask(question, yes, no) {
//     if (confirm(question)) yes()
//     else no();
//   }
  
//   function showOk() {
//     alert( "Вы согласны." );
//   }
  
//   function showCancel() {
//     alert( "Вы отменили выполнение." );
//   }
  
//   // использование: функции showOk, showCancel передаются в качестве
            //аргументов ask
//   ask("Вы согласны?", showOk, showCancel);
// На практике подобные функции очень полезны. Основное отличие 
    // «реальной» функции ask от примера выше будет в том, что она 
    // использует более сложные способы взаимодействия с пользователем,
    // чем простой вызов confirm. В браузерах такие функции обычно 
    // отображают красивые диалоговые окна.
// Аргументы функции ask ещё называют функциями-колбэками или просто 
//     колбэками.
// Ключевая идея в том, что мы передаём функцию и ожидаем, что она 
    // вызовется обратно (от англ. «call back» – обратный вызов)
    // когда-нибудь позже, если это будет необходимо. В нашем случае,
    // showOk становится колбэком для ответа «yes», а showCancel – для
    // ответа «no».
// Мы можем переписать этот пример значительно короче, используя 
    // Function Expression:

// function ask(question, yes, no) {
//   if (confirm(question)) yes()
//   else no();
// }

// ask(
//   "Вы согласны?",
//   function() { alert("Вы согласились."); },
//   function() { alert("Вы отменили выполнение."); }
// );
// Здесь функции объявляются прямо внутри вызова ask(...). У них нет
    // имён, поэтому они называются анонимными. Такие функции 
    // недоступны снаружи ask (потому что они не присвоены переменным),
    // но это как раз то, что нам нужно.
// Функция – это значение, представляющее «действие». Обычные значения,
//     такие как строки или числа представляют собой данные. Функции,
//     с другой стороны, можно воспринимать как «действия». Мы можем
//     передавать их из переменной в переменную и запускать, 
//     когда захотим.
//------- Function Expression в сравнении с Function Declaration--------
// Во-первых, синтаксис: как определить, что есть что в коде.
// Function Declaration: функция объявляется отдельной конструкцией 
//     «function…» в основном потоке кода.

// function sum(a, b) {
//   return a + b;
// }

// Function Expression: функция, созданная внутри другого выражения или
    // синтаксической конструкции. В данном случае функция создаётся в
    // правой части «выражения присваивания» =:

// let sum = function(a, b) {
//   return a + b;
// };
// Более тонкое отличие состоит, в том, когда создаётся функция движком
//     JavaScript.
// Function Expression создаётся, когда выполнение доходит до него, и 
//     затем уже может использоваться.
// Function Declaration можно использовать во всем скрипте (или блоке
//     кода, если функция объявлена в блоке).

// Ещё одна важная особенность Function Declaration заключается в их 
//     блочной области видимости:
// В строгом режиме, когда Function Declaration находится в блоке {...},
//     функция доступна везде внутри блока. Но не снаружи него.
// Как правило, если нам понадобилась функция, в первую очередь нужно 
//     рассматривать синтаксис Function Declaration, который мы 
//     использовали до этого. Он даёт нам больше свободы в том, как мы
//     можем организовывать код. Функции, объявленные таким образом,
//     можно вызывать до их объявления.
// Также функции вида function f(…) {…} чуть более заметны в коде, чем
//     let f = function(…) {…}. Function Declaration легче «ловятся 
//     глазами». Hо если Function Declaration нам не подходит по 
//     какой-то причине (мы рассмотрели это в примере выше), то можно
//     использовать объявление при помощи Function Expression.
// Процесс "всплывания" декларированных функций к началу файла 
//     называется хойстинг
 
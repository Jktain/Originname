//-----------------------  ------------------------
// Современные способы установки и прямого доступа к прототипу это:

// 1) Object.create(proto[, descriptors]) – создаёт пустой объект со 
//     свойством [[Prototype]], указанным как proto (может быть null),
//     и необязательными дескрипторами свойств.
// 2) Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] 
//     объекта obj (то же самое, что и геттер __proto__).
// 3) Object.setPrototypeOf(obj, proto) – устанавливает свойство 
//     [[Prototype]] объекта obj как proto (то же самое, что и сеттер 
//     __proto__).
// Встроенный геттер/сеттер __proto__ не безопасен, если мы хотим 
//     использовать созданные пользователями ключи в объекте. 
//     Как минимум потому, что пользователь может ввести "__proto__"
//     как ключ, от чего может возникнуть ошибка. Если повезёт – 
//     последствия будут лёгкими, но, вообще говоря, они непредсказуемы

// Так что мы можем использовать либо Object.create(null) для создания
//     «простейшего» объекта, либо использовать коллекцию Map.

// Кроме этого, Object.create даёт нам лёгкий способ создать 
//     поверхностную копию объекта со всеми дескрипторами:

// let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
// Мы также ясно увидели, что __proto__ – это геттер/сеттер для 
//     свойства [[Prototype]], и находится он в Object.prototype, как и
//     другие методы.

// Мы можем создавать объекты без прототипов с помощью 
//     Object.create(null). Такие объекты можно использовать как 
//     «чистые словари», у них нет проблем с использованием 
//     строки "__proto__" в качестве ключа.

// Ещё методы:

// 1) Object.keys(obj) / Object.values(obj) / Object.entries(obj) 
//     – возвращают массив всех перечисляемых собственных строковых 
//     ключей/значений/пар ключ-значение.
// 2) Object.getOwnPropertySymbols(obj) – возвращает массив всех 
//     собственных символьных ключей.
// 3) Object.getOwnPropertyNames(obj) – возвращает массив всех 
//     собственных строковых ключей.
// 4) Reflect.ownKeys(obj) – возвращает массив всех собственных ключей.
// 5) obj.hasOwnProperty(key): возвращает true, если у obj 
//     есть собственное (не унаследованное) свойство с именем key.
// Все методы, которые возвращают свойства объектов (такие как 
//     Object.keys и другие), возвращают «собственные» свойства. 
//     Если мы хотим получить и унаследованные, можно воспользоваться
//      циклом for..in.

//-------------------  --------------------


//-----------------  -----------------


//------------------------  --------------------------


//--------------------------  -----------------------------


//--------------------------  --------------------------

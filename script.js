//---------------------- Функция-конструктор --------------------------
// Опциональная цепочка ?. останавливает вычисление и возвращает 
//     undefined, если значение перед ?. равно undefined или null.

// Далее в этой статье, для краткости, мы будем говорить, что что-то
//     «существует», если оно не является null и не undefined.

// Другими словами, value?.prop:

// 1) работает как value.prop, если значение value существует,
// 2) в противном случае (когда value равно undefined/null) он 
//     возвращает undefined.
// Вот безопасный способ получить доступ к user.address.street, 
//     используя ?.:

// let user = {}; // пользователь без адреса

// alert( user?.address?.street ); // undefined (без ошибки)
// Код лаконичный и понятный, в нем вообще нет дублирования.

// А вот пример с document.querySelector:

// let html = document.querySelector('.elem')?.innerHTML;
// Считывание адреса с помощью user?.address работает, даже если 
//     объект user не существует:

// let user = null;

// alert( user?.address ); // undefined
// alert( user?.address.street ); // undefined
// Обратите внимание: синтаксис ?. делает необязательным значение 
//     перед ним, но не какое-либо последующее.

// Так например, в записи user?.address.street.name ?. позволяет user
//     безопасно быть null/undefined (и в этом случае возвращает
//     undefined), но это так только для user. Доступ к последующим 
//     свойствам осуществляется обычным способом. Если мы хотим, 
//     чтобы некоторые из них были необязательными, тогда нам нужно 
//     будет заменить больше . на ?..

// Не злоупотребляйте опциональной цепочкой
// Нам следует использовать ?. только там, где нормально, что чего-то 
//     не существует.

// К примеру, если, в соответствии с логикой нашего кода, объект user 
//     должен существовать, но address является необязательным, то нам
//     следует писать user.address?.street, но не user?.address?.street.

// В этом случае, если вдруг user окажется undefined, мы увидим 
//     программную ошибку по этому поводу и исправим её. В противном 
//     случае, если слишком часто использовать ?., ошибки могут 
//     замалчиваться там, где это неуместно, и их будет сложнее 
//     отлаживать.

// Переменная перед ?. должна быть объявлена
// Если переменной user вообще нет, то user?.anything приведёт к ошибке:

// ReferenceError: user is not defined
// user?.address;
// Переменная должна быть объявлена (к примеру, как let/const/var user
//     или как параметр функции). Опциональная цепочка работает только с
//     объявленными переменными.

//----------------------- Сокращённое вычисление -----------------------
// Как было сказано ранее, ?. немедленно останавливает вычисление, 
//     если левая часть не существует.

// Так что если после ?. есть какие-то вызовы функций или операции, 
//     то они не произойдут.

// Например:

// let user = null;
// let x = 0;

// user?.sayHi(x++); // нет "user"

// alert(x); // 0, значение не увеличилось

//-------------- Другие варианты применения: ?.(), ?.[] ----------------
// Опциональная цепочка ?. — это не оператор, а специальная 
//     синтаксическая конструкция, которая также работает с функциями
//     и квадратными скобками.

// Например, ?.() используется для вызова функции, которая может 
//     не существовать.

// В приведённом ниже коде у некоторых наших пользователей есть 
//     метод admin, а у некоторых его нет:

// let userAdmin = {
//   admin() {
//     alert("Я админ");
//   }
// };

// let userGuest = {};

// userAdmin.admin?.(); // Я админ

// userGuest.admin?.(); // ничего не произойдет (такого метода нет)
// Здесь в обеих строках мы сначала используем точку (userAdmin.admin),
//     чтобы получить свойство admin, потому что мы предполагаем, 
//     что объект user существует, так что читать из него безопасно.

// Затем ?.() проверяет левую часть: если функция admin существует, 
//     то она запускается (это так для userAdmin). В противном случае 
//     (для userGuest) вычисление остановится без ошибок.

// Синтаксис ?.[] также работает, если мы хотим использовать скобки []
//     для доступа к свойствам вместо точки .. 
//     Как и в предыдущих случаях, он позволяет безопасно считывать 
//     свойство из объекта, который может не существовать.

// let key = "firstName";

// let user1 = {
//   firstName: "John"
// };

// let user2 = null;

// alert( user1?.[key] ); // John
// alert( user2?.[key] ); // undefined
// Также мы можем использовать ?. с delete:

// delete user?.name; // удаляет user.name если пользователь существует

// Мы можем использовать ?. для безопасного чтения и удаления, 
//     но не для записи
// Опциональная цепочка ?. не имеет смысла в левой части присваивания.

// Например:

// let user = null;

// user?.name = "John"; // Ошибка, не работает
// то же самое что написать undefined = "John"

//-----------------  --------------------